# Строение GNU/Linux. Часть 1.

Дистрибутив по Linux for yourself собрать нельзя, не умея читать документацию, искать нужную информацию в интернете и не зная строение Linux. Именно о строении и пойдёт речь в этой статье. Первая часть даст базовые сведения, а в следующих частях структура типичного Linux-дистрибутива будет рассмотрена подробнее.

_Linux for yourself_ старается придерживаться стандартов `FHS` и `LSB` (о них далее).

## Термины

- `FHS` (`Filesystem Hierarchy Standart`) - документ, который определяет схему директорий в UNIX-системах. FHS разработан, чтобы предоставить общую схему для упрощения независимой от дистрибутива разработки `программного обезпечения` (далее - `ПО`). Другими словами, это стандарт, унифицирующий местонахождение файлов и каталогов с общим назначением в файловой системе UNIX. Таблицу директорий и другую информацию вы сможете лицезреть [здесь](additional/partition_catalogs).
- `LSB` (`Linux Standart Base`) - совместный проект дистрибутивов Linux при организации Linux Foundation, целью которого является стандартизация их внутренней инфраструктуры. Цель LSB - разработать и продвигать набор стандартов, который увеличит совместимость различных дистрибутивов Linux и даст возможность запускать приложения на любой совместимой системе; помимо этого, LSB помогает сконцентрировать усилия в привлечении разработчиков к написанию и портированию ПО. LSB сертифицирует стандартные библиотеки, пару утилит, структуру иерархии `файловой системы` (далее - `ФС`), уровни запуска и et cetera.
- `конфиг` - сленговое. Означает "конфигурационный файл".
- `юзер` - сленговое. Означает "пользователь".
- `ФС` - сокращение от "файловая система".

## Filesystem Hierarchy Standard

В данном разделе речь пойдёт про иерархию ФС Linux. Может быть применимо и к другим UNIX-Like системам и дистрибутивам, главное, чтобы они соответствовали стандарту `FHS`. Всякие NixOS и Gobo Linux не рассматриваем.

## Независимые классификации в FHS

Спецификация FHS основывается на идее существования двух независимых классификаций файлов: разделяемых и неразделяемых, а также изменяемые и статичные. Разделяемые данные могут распространяться на несколько хостов; неразделяемые специфичны для конкретного хоста (например, конфиги). Соответственно, изменяемые файлы изменяются, а статичные - нет (за исключением установки и обслуживания системы).

Резюме. 4 возможные комбинации + нужные директории.

| -          | Разделяемые | Неразделяемые |
| ---------- | :---------: | :-----------: |
| статичные  |  /usr /opt  |  /etc /boot   |
| изменяемые |  /var/mail  |   /var/run    |

## Само строение ОС

### Процесс загрузки

> В данной статье загрузка ПК, BIOS, UEFI и прочее будет пропущено, ибо это не тема этой статьи.

Начнём с загрузчика. Их очень много - `GRUB2`, `rEFInd`, `systemd-boot`, `syslinux` и другие. Но самым популярным является, конечно, `GRUB2`.
Задача загрузчика - инициализировать ядро Linux (в нашем случае). В помощь ядру загрузчик обычно использует начальный образ загрузки - `initrd` или `initramfs`, представляющий собой архив с образом файловой системы, разворачивающейся в ОЗУ в начале загрузки. В `initrd`/`initramfs` находятся нужные драйверы, скрипты и прочее, что необходимо для инициализации оборудования и прочих целей.

---

После начального образа загружается ядро. Находится в `/boot`, в своём названии имеет `vmlinuz`:

- `vm` - поддержка виртуальной памяти;
- `linu` - когда-то называлось `linux`, но позже сократилось до текущего состояния, потому что необходимо указать факт сжатия ядра (следующий пункт);
- `z` - указатель того, что файл с ядром сжат (Поддерживаются форматы сжатия: gzip, bzip2, lzma, xz, lzo, lz4, zstd).

Ядро Linux является `монолитным`.

**Плюсы монолитного ядра**

- Более прямой доступ к аппаратным средствам
- Проще обмен данными между процессами
- Процессы реагируют быстрее

**Минусы монолитного ядра**

- Большой размер
- Занимает много оперативной памяти
- Менее безопасно

Монолитное ядро больше и несколько сложнее других видов ядер. Ну и вспомните спор Таненбаума и Торвальдса. Но у Linux есть достоинство - это _модули ядра_. Подключать нужные модули можно буквально на лету. вы можете запускать процессы сервера, подключать виртуализацию, а также полностью заменить ядро без перезагрузки. Например, команда

```bash
modprobe qemu-nbd
```

Подключит соответствующий модуль `qemu-nbd`.

GNU/Linux состоит из четырёх основных частей:

- `Ядро Linux` — основная интересующая нас часть; ядро создаёт абстрактный слой и является «посредником» между первыми двумя частями и hardware-частью компьютера;
- `Hardware controllers` (контроллеры оборудования) — подсистема, охватывающая все возможные физические устройства, такие как CPU, устройства памяти, жёсткие диски, сетевые карты — все они являются частью этой подсистемы
- `OS services` (службы операционной системы) — службы, которые обычно считаются частью операционной системы.
- `User applications` (пользовательские приложения) — набор пользовательских приложений, который в разных дистрибутивах Linux может быть разным. Например, в Linux For Yourself предложен самый небольшой набор ПО, которого хватит для корректной работы операционной системы.

![kernel1](pic/kernel1.jpg)

Каждая подсистема может взаимодействовать только с двумя соседними, расположенными непосредственно «выше» и «ниже» её уровня. Кроме того, зависимости между этими подсистемами направлены сверху вниз: слои, расположенные выше — зависят от частей ниже, но части, расположенные ниже — не зависят от частей выше их.

Ядро Linux состоит из пяти основных подсистем:

- `Process Scheduler` (`SCHED`) — планировщик процессов, отвечает за контроль над доступом процессов к CPU. Планировщик обеспечивает такое поведения ядра, при котором все процессы имеют справедливый доступ к центральному процессору;
- `Memory Manager` (`MM`) — менеджер памяти, обеспечивает различным процессам безопасный доступ к основной памяти системы. Кроме того, MM обеспечивает работу виртуальной памяти, которая позволяет процессам использовать больше памяти, чем реально доступно в системе. Выделенная, но неиспользуемая память вытесняется на файловую систему, и при необходимости — возвращается из неё обратно в память (swapping);
- `Virtual File System` (`VFS`) — виртуальная файловая система, создаёт абстрактный слой, скрывая детали оборудования, предоставляя общий файловый интерфейс для всех устройств. Кроме того, VFS поддерживает несколько форматов файловых систем, которые совместимы с другими операционными системами;
- `Network Interface` (`NET`) — сетевые интерфейсы, обеспечивает работу с различными сетевыми стандартами и сетевым оборудованием;
- `Inter-Process Communication` (`IPC`) — межпроцессная подсистема, поддерживающая несколько механизмов для process-to-process связей в единой Linux-системе.

![kernel2](pic/kernel2.gif)
![kernel3](pic/kernel3.png)

Символом ядра Linux является Tux, отличающийся от «обычных» пингвинов жёлтым цветом клюва и лап. Однако, в качестве символа Linux 2.6.29 был принят Tuz (тасманский дьявол), изображение которого ранее служило талисманом конференции linux.conf.au 2009. В следующих версиях ядра используется предыдущий пингвин Tux. Его можно наблюдать и поныне.

![Tux](pic/Tux.png)
_Tux_

![Tuz](pic/Tuz.png)
_Tuz_

---

После ядра стартует `init` - подсистема инициализации в UNIX-ах, которая запускает все остальные процессы. Имеет `PID`=1. Раньше, де-факто стандартным инитом в GNU/Linux был SysVinit. Однако, в самом начале 10-ых были попытки заменить SysVinit на другую систему инициализации. Например, в Ubuntu первое время использовался `upstart` от Canonical, а в Gentoo Linux используется OpenRC. Также был создан `systemd`, на который в данный момент перешло большинство дистрибутивов Linux.

**Достоинства `systemd`**

- _Агрессивная параллелизация_ и прочее, что позволяет существенно ускорить загрузку ОС
- Запуск сервисов по расписанию (вместо `cron`)
- Смена корня (вместо `chroot`)
- Простой и лаконичный синтаксис служб

**Недостатки `systemd`**

- Не _Unix Way_. systemd - монолитная и сложная система, заменяющая собой не только инит, но и планировщик, менеджер сети, утилиту по смене корня системы, просмотрщик логов и пр, что не особо нужно многим пользователям
- systemd требуется несколько больше ресурсов, чем его менее прожорливым товарищам, из-за чего на старом железе лучше использовать дистрибутив с другой системой инициализации, например, классическим `SysVinit`

И теперь про `SysVinit`.

**Достоинства `SysVinit`**

- Устоявшаяся и хорошо понятная система
- Простая настройка
- Стабильная и надёжная работа

**Недостатки `SysVinit`**

- Неудобная (а для некоторых ещё и сложная) работа с сервисами
- Последовательная обработка задач загрузки, что может в некоторых случаях замедлить скорость старта ОС

---

После инита загружается `командная оболочка`, коих так же довольно много:

- `bourne shell` (sh) - "тот самый";
- `bourne again shell` (bash) - ставшая классической в Linux оболочка, которая используется во многих дистрибутивах по умолчанию. В Linux for yourself `/bin/sh` является символической ссылкой на `/bin/bash`;
- `BusyBox` - представляет собой целое пользовательское окружение, в том числе, командную оболочку (вызов: `busybox sh`). Достоинство: малый размер и небольшие требования к аппаратуре;
- `Z shell` (zsh) - мощная современная оболочка. Она почти полностью совместима с bash, но имеет преимущества, такие как улучшенное завершение на клавишу Tab (англ. tab completion), автоматическое исправление опечаток и огромное количество разработанных сообществом плагинов. К слову, именно она по умолчанию используется в macOS.
- `friendly interactive shell` (fish) - удобная оболочка, которая "из коробки" имеет подсветку синтаксиса, автодополнения, генерируемые из мануалов, и т. п. Из минусов нужно выделить несовместимость со спецификацией POSIX sh;
- et cetera.

Командная оболочка прописана в стандарте POSIX и необходима для работы системы.
В Linux for yourself список оболочек содержится в файле `/etc/shells`.

---

Далее идёт графика. О ней можно говорить очень много, ибо тема довольно объёмная, но я опишу всё вкратце.

Состоит из следующих компонентов:

- `Display Server` - дисплейный сервер;
- `Display Manager` (DM) - дисплейный менеджер;
- `Desktop Manager` (DE) - рабочее окружение.

Рабочее окружение (DE) можно разделить на следующее:

- `WM` (Window Manager) - программа, которая управляет отображением окон в системе GUI (Graphic User Interface) - графическом интерфейсе пользователя;
- Средство запуска ПО;
- Панель, на которой располагаются апплеты/виджеты:
  - средство запуска приложений;
  - апплет переключения между открытыми окнами;
  - апплет системного трея;
  - другие апплеты/виджеты по усмотрению пользователя.
- Файловый менеджер, задача которого - не только работа с файлами, но и управление иконками на рабочем столе;
- Менеджер обоев рабочего стола;
- Приложения по умолчанию (эмулятор терминала, файловый менеджер (см. по списку выше), настройки системы и рабочего окружения, et cetera);
- et cetera.

???+ example

    Хочу заострить ваше внимание на том, что оконный менеджер, панель и некоторые другие компоненты можно использовать и отдельно от рабочего окружения. Например, оконные менеджеры Fluxbox, Openbox, i3-wm, Awesome, Sway и др. используются отдельно от DE. Также существуют отдельные файловые менеджеры, которые так же поставляются отдельно от рабочего окружения.

???+ warning "Предупреждение"

    Не путайте понятия "рабочий стол" и "рабочее окружение". Хотя эти два термина похожи, но значения немного разные.

---

Теперь описание компонентов графики.

### Display server

Дисплейный сервер - программа, отвечающая за координацию ввода и вывода своих клиентов с ОС, а также между оборудованием и ОС. Именно благодаря Display Server вы используете Linux в графическом режиме, а не в TTY. Когда говорят "дисплейный сервер", нередко имеют ввиду `Xorg`, `Wayland`, `Mir` и прочие.

### Display Manager

Первая программа, которая запускается при старте графики. Её основные задачи:

- запросить аутентификационные данные нужного пользователя (имя, пароль или отпечаток пальца);
- выбрать, какую среду рабочего стола запустить.

Примеры DM:

- LightDM;
- XDM;
- GDM (из состава GNOME);
- SDDM (из состава KDE);
- TDM (из состава Trinity);
- WDM (из состава Window Maker).

Как и упоминалось ранее, дисплейные менеджеры можно использовать и отдельно от DE.

### Window Manager

Я не случайно начал именно с WM. Во-первых, про DE было сказано выше, а во-вторых, оконный менеджер можно использовать отдельно от всего громоздкого рабочего окружения.
Что такое `WM` было так же сказано выше. Можно выделить три вида оконных менеджеров:

- `Стековые` (`плавающие`, англ. `stacking`, `floating`) следуют классической метафоре, которая на данный момент самая удобная и популярная. Классическое расположение окон, которые могут накладываться и перекрывать друг друга;
- `Фреймовые` (англ. `tiling`) WM располагают окна в виде `фреймов` (`плиток`), эти фреймы не способны перекрывать друг друга, подобное поведение встречается в графическом интерфейсе _Windows_ 1.x. Наиболее удобно использовать такие оконные менеджеры посредством клавиатуры, хотя поддержка мыши во многих из них также присутствует;
- `Динамические` (например, i3wm) - динамически переключаются между двумя режимами, описанными выше (`стековый` и `фреймовый` режимы). Поддержка мыши есть в большинстве из них.
